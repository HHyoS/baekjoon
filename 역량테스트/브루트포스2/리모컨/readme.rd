문제 사이트 : https://www.acmicpc.net/problem/1107

설명 
  수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.

리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.

수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오. 

수빈이가 지금 보고 있는 채널은 100번이다.

풀이 
 주어진 조건에 맞추어 주어진 N 채널을 갈 때 최소 횟수를 구하는 문제입니다.
 
 위의 문제 해결을 위해서 생각한 방법은 N으로 가는 최소 버튼사용 횟수는
 
 N을 기준으로 숫자 버튼을 눌러서 갈 수 있는 가장 빠른 위, 아래채널을 찾은 뒤 해당 채널들에서 N으로 갈때
 
 사용하는 버튼의 횟수 두가지와, 현재 위치하고잇는 채널 100에서 위아래 버튼을 눌러서 N까지 가는 방법 세가지
 
 중에 하나라는 사실입니다.
 
 그것을 이용하여 현재 (1) N부터 0까지 (2) N부터 N*2의 숫자인 100만까지 탐색하고 그 값들이 (3) 100에서 N까지
 
 와 비교된 후 최솟값을 출력하도록 하였습니다.
 
 #include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
#define M 1000000
bool p[10] = { 0, };

int cal(int v) { // 현재 위치를 갈 때 사용한 버튼이 사용가능한지 판단하는 함수 cal
    int count = 0;
    if (v == 0) { // 입력된 수 v 가 0 일경우 v 는 무조건 0 이기 때문에 43번의 while문을 생략하고 0을 출력하기 때문에
    // 위의 if문을 통해 v가 0인지 판단하고 0일경우 사용가능한 0인지 판단 후 return
        if (p[0] == 0)
            return 1;
        else
            return -1;
    }
    
    while (v > 0) { // 주어진 채널이 사용가능한 버튼으로만 구성되있는지 확인한 후
        if (p[v % 10] == 0) {
            v /= 10;
            ++count;
        }
        else {
            return -1;
        }
    }
    return count; // 사용가능한 버튼들로만 구성되었을 경우 사용한 버튼수 return
}
int main() {
    int n,m;
    scanf("%d%d", &n,&m);
    int answer = abs(100 - n);
    if (m > 0) {
        int a;
        while (m--) {
            scanf("%d", &a);
            p[a] = 1; // 사용 불가능한 버튼 체크
        }
    }
    for (int a = n; a >= 0; --a) { // n부터 0까지 탐색해가며 사용가능한 버튼으로 구성된 근거리 채널 찾기
        if ((cal(a) != -1)) { // -1이 아니면 사용가능한 버튼들로만 구성된 채널
            if (cal(a) + abs(n - a) < answer)
                answer = cal(a) + abs(n - a); // 가장 가까운 채널이 answer값과 비교했을 때 더 작을경우 answer에 입력
            else
                break; // 더 크면 이후 채널도 더 큰값을 갖기 때문에 for문이 의미없으므로 break;
        }
    }
    for (int a = n; a <= M; ++a) { // 66~73번 for문과 동일한 기능
        if ((cal(a) != -1)){
            if (cal(a) + abs(n - a) < answer)
                answer = cal(a) + abs(n - a);
            else
                break;
        }
    }
    printf("%d", answer); // answer 출력
    return 0;
}
