문제 사이트 : https://www.acmicpc.net/problem/11053

문제 설명

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은

A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

풀이

주어진 수열에서 가장 긴 오름차순의 수열의 길이를 구하는 문제였습니다.

해당 문제 풀이를 할 때 생각한 방법은 n번쨰 수열을 작성할 때 1~n-1 번째 까지의 수열 중 n번째 수보다 작은 

수를 찾은 뒤 해당 수에서 현재 수를 연결하여 수열을 완성하는 값과, 원래 작성된 최장 수열의 길이를 저장한

배열의 값을 비교하여 더 긴 값을 저장하는 방식으로 해결하는것 이였습니다.

#include <cstdio>
#include <algorithm>
using namespace std;


int main() {
    int n;
    int ar[1000 + 1] = { 0, };
    scanf("%d", &n);
    for (int a = 1; a <= n; ++a) {
        scanf("%d", &ar[a]);
    }
    int dp[1000 + 1] = { 0 }; // 원래는 모든 수열의 길이는 최소 1이므로 1로 초기화해야하나 마지막에 1을 더하는것으로 해결
    for (int a = 2; a <= n; ++a) {
        for (int b = 1; b < a; ++b) {
            if (ar[b] < ar[a]) { // 현재 값인 ar[a]보다 이전에 존재하는 ar[b]값이 작다면
                dp[a] = max(dp[a], dp[b] + 1); // 작성된 dp[a]값과, dp[b]에서 현재값을 연결한 dp[b]+1
                // 값 중 큰 값을 dp[a]에 저장
            }
        }
    }
    printf("%d", *max_element(dp,dp+n+1)+1); // dp배열 중 최대값을 찾고, 33번 줄에서 초기화 안한 +1을 
    // 더하기
    return 0;
}
