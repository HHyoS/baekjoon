문제 사이트 : https://www.acmicpc.net/problem/15990

문제 설명

  정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

  1+2+1
  1+3
  3+1
  정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

1,2,3 더하기 문제 시리즈 5번째 문제입니다.

dp문제 해결방식의 변형으로 같은 수의 반복을 2회이상 사용하면 안된다는 조건이 붙어있습니다.

그래서 문제를 해결할 때, f(x) = f(x-1) + f(x-2) .... 의 방식을 사용하기 위해 각 f(x)의 값을 구하는 배열을

3개로 나누어 1,2,3 으로 끝날때를 각각 배열로 선언하였습니다.

그리고 새로운 f(x)를 구할때 일반적으로는 f(x) = f(x-1)[1로 끝날때] + f(x-2)[2로 끝날때] 등으로 표현되는 식을

f(x) = f(x-1)(2와 3으로 끝나는 경우의수의합) + f(x-2)(1과 3으로 끝나는 경우의 수의 합)
       f(x-3)(1과 2로 끝나는 경우의 수의 합)
       
을 구하도록 알고리즘을 설계하여 문제를 해결하였습니다.

#include <cstdio>
using namespace std;

int dp[100000 + 1][3] = { 0, };
int main() {
    int n;
    scanf("%d", &n);
    dp[1][0] = 1;
    dp[2][1] = 1;
    dp[3][0] = 1;
    dp[3][1] = 1;
    dp[3][2] = 1;
    int num;
    int index = 3;
    while (n--) {
        scanf("%d", &num);
        if (num > index) {
            for (int a = index+1; a <= num; ++a) {
                dp[a][0] = (dp[a - 1][1] + dp[a - 1][2]) % 1000000009;
                dp[a][1] = (dp[a - 2][0] + dp[a - 2][2]) % 1000000009;
                dp[a][2] = (dp[a - 3][0] + dp[a - 3][1]) % 1000000009;
            }
            index = num;
        }
        printf("%d\n", ((dp[num][0] + dp[num][1]) % 1000000009 + dp[num][2]) % 1000000009);
    }
    return 0;
}

사소한 궁금.
  초기에는 경우의 수를 구해야 하는 수를 arr배열을 설정하여 저장한 뒤 해당 값중 가장 큰 값을 찾아
  
  해당 값까지만 for문을 통해 dp배열을 완성했었는데, 그렇게 진행하여도 주어질 수 있는 값의 최대인 100000을 미리 연산 한 뒤, 입력받는
  
  값에 대하여 저장된 값을 출력하는 방식으로 문제를 해결하는 방법보다 메모리 사용측면에서 개선되는 점이 없었습니다.
  
  머리속으로는 제한된 양을 정하여 연산하는것이 빠르고 메모리 사용이 적다고 생각하는데, 컴퓨터의 연산은
  
  다른것 같습니다. 어떤 방식을 이용하면 개선할 수 있을지 더 공부해봐야 겠습니다.
