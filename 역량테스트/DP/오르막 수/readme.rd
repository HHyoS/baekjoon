문제 사이트 : https://www.acmicpc.net/problem/11057


설명
  오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.

  예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.

  수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.
  
  N이 주어졌을 때 가능한 모든 오르막의 수를 구하는 문제입니다.
  
  문제를 해결하기위해 규칙을 찾아보니, 마지막에 들어가는 수가 X일때 f(n)[X]의 경우의 수는
  
  n이 1일때 f(n)[0]을 제외한 모든 값을 1로 초기화 시킨뒤 규칙을 찾으면
  
  n>= 2 일 때, f(n)은 X >=1 일 떄 f(n) = f(n-1)[X] + f(n)[X-1]라는 규칙이 성립하였고, f(n)[0] 은 항상 0이였습니다.
  
  해당 규칙을 바탕으로 프로그램을 작성하였고, 새로운 배열을 작성할 때, 직전 f(n-1) 배열만이 필요했기 때문에
  
  배열의 크기는 2로 설정한 뒤 두개의 배열을 바탕으로 값을 갱신해가며 문제를 해결하였습니다.
  
  #include <cstdio>
using namespace std;

#define M 10007

int dp[2][10] = { 0, }; // 직전 배열의 값과 새롭게 작성된 배열의 값을 저장하는 배열
int main() {
    int n;
    scanf("%d", &n);
    for (int a = 1; a < 10; ++a) {
        dp[1][a] = 1; // 초기값 세팅
    }
    int sum = 10; // 경우의 수 의 합 초기값 세팅

    for (int a = 2; a <= n; ++a) {
        int index = a % 2;
        for (int b = 1; b < 10; ++b) { 
            dp[index][b] = (dp[index][b - 1] + dp[!index][b])%M;  // 문제의 조건에 맞춰 나머지값을 새로운 배열에 저장하며 
            sum = (sum + dp[index][b]) % M; // 경우의 수의 합을 더하여 갱신
        }
    }

    printf("%d", sum);
    return 0;
}
