문제 사이트 : https://www.acmicpc.net/problem/10844

문제 설명 : 45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

인접한 수로만 이루어진 길이가 N인 수의 갯수를 구하는 문제였습니다.

문제를 해결하기위해 왼쪽에서부터 n번째의 수를 작성할 때 나올 수 있는 경우의 수인 0~9까지를

작성하여 규칙을 찾아봤을 떄, 0과 9를 제외한 모든 수는 n번째 자리에 x라는 수가 들어갈 때

f(n-1)번쨰의 x-1 수가 들어갈 때 경우의 수와 x+1 수가 들어갈 때 경우의 수의 합이라는 사실을 찾았습니다.

ex) f(n)이라는 수의 경우의 수를 찾을떄 n이 4라고 가정할 떄 ???X 라는 n번쨰 자리에 X라는 수가 들어갈 떄

X가 1~8 일 경우 f(n-1)[x-1]과 f(n-1)[x+1] 의 합이 경우의 수이고

0일경우 f(n-1)[1], 9일경우 f(n-1)[8].

위의 규칙을 확인한 후 코드를 간결화 하기위해 0~9숫자가 들어가지만 배열의 크기를 12로 저장하여

X 가 0일경우에도 양옆의 경우의 수를 더할 수 있도록 항상 0인 -1번째 자리를 만들어주고 9일경우에도 우측에

더할 수 있는 자리를 만들어서 식을 간결하게 작성할 수 있도록 하였습니다.

하지만 배열에 -1번째 자리는 없기 때문에 f(n)[0] 이 -1번쨰 자리를 f(n)[11]에는 9일경우 더할 수 있는 자리의 수

를 생성하였습니다.

#include <cstdio>
using namespace std;

#define M 1000000000

int dp[2][12] = { 0, }; // 배열의 최신화를 위해서는 전 단계의 배열만 필요하므로 배열을 두개만 생성하여 메모리 사용 최소화
int main() {
    int n;
    scanf("%d", &n);
    for (int a = 2; a <= 10; ++a) {
        dp[0][a] = 1; // 초기값 세팅
    }

    int index = 1; // 현재 배열 위치 중 어디를 작성하고 있는지 
    for (int a = 2; a <= n; ++a) {
        for (int b = 1; b <= 10; ++b) {
            if (index == 1) {
                dp[1][b] = (dp[0][b - 1] + dp[0][b + 1]) % M;
            }
            else if (index == 0) {
                dp[0][b] = (dp[1][b - 1] + dp[1][b + 1]) % M;
            }
        }
        index = !index;
    }

    int sum = 0;
    for (int a = 1; a <= 10; ++a) {
        sum = (sum + dp[!index][a]) % M;
    }
    printf("%d", sum);
    return 0;
}
