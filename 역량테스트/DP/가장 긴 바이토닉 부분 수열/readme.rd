문제 사이트 : https://www.acmicpc.net/problem/11054

설명

수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

풀이

바이토닉 수열 중 가장 긴 수열의 길이를 구하는 문제였습니다.

문제의 조건인 바이토닉 수열은 특정 수를 기준으로 좌측은 오름차순, 우측은 내림차순으로 진행하는 수열중 가장 킨 

수열을 의미합니다.

그 의미를 만족하는 풀이방법 중 제가 생각한 방법은 특정 수를 기준으로 가장 긴 수열은 찾기보다는

주어진 수열을 바탕으로 좌측부터 시작하는 오름차순, 우측부터 시작하는 오름차순 두가지를 만든 뒤

특정 위치에서 두가지 오름차순의 합이 가장 큰 수를 찾는 방법입니다.

#include <cstdio>
#include <algorithm>
using namespace std;


int main() {
    int n;
    int ar[1000 + 1] = { 0, }; // 주어진 입력 저장, 1로 세팅해야하지만 마지막에 1을 더하여 해결하기로함
    int dp[1000 + 1][2] = { 0 }; // 좌측에서부터 시작하는 오름차순 dp[][0], 우측에서부터 시작하는 오름차순
    // dp [][1]
    scanf("%d", &n);
    for (int a = 1; a <= n; ++a) {
        scanf("%d", &ar[a]);
    }
    for (int a = 2; a <= n; ++a) { // 39~45라인은 좌측에서 시작하는 오름차순 dp
        for (int b = 1; b < a; ++b) {
            if (ar[b] < ar[a]) {
                dp[a][0] = max(dp[a][0], dp[b][0] + 1);
            }
        }
    }
   for (int a = n-1; a >= 1; --a) { // 46~52 라인은 우측에서 시작하는 오름차순 dp
        for (int b = n; b > a; --b) {
            if (ar[b] < ar[a]) {
                dp[a][1] = max(dp[a][1], dp[b][1] + 1);
            }
        }
    }
    int big = 0;
    for (int a = 1; a <= n; ++a) { // 54~58번 라인은 특정 인덱스에서 dp[a][0] + dp[a][1] 이 가장 큰
    // 바이토닉 수열을 찾는 for문
        if (big < dp[a][1] + dp[a][0]){
            big = dp[a][1] + dp[a][0];
        }
    }
    printf("%d\n", big+1); // 겹치는 부분이 있으므로 +2가 아닌 +1 
    return 0;
}
