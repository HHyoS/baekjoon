문제 사이트 : https://www.acmicpc.net/problem/13398


설명

n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 수를 제거하지 않았을 때의 정답은 12+21인 33이 정답이 된다.

만약, -35를 제거한다면, 수열은 10, -4, 3, 1, 5, 6, 12, 21, -1이 되고, 여기서 정답은 10-4+3+1+5+6+12+21인 54가 된다.

풀이

연속합 문제의 조건 중 수열에서 하나를 뺄 수있는 조건이 추가된 문제입니다.

해당 문제를 해결하기 위해 입력받은 수열을 저장하는 배열 ar을 ar[][2]로 선언하여

수열에서 하나도 안뺏을 때 최대값을 저장하는 ar[][0], 하나를 뺏을 때 최대값을 저장하는 ar[][1] 을 사용했습니다.

그리고 for문을 이용하여 ar[a][0]에는 ar[a][0]과 ar[a-1][0] + ar[a][0] 중 더 큰값을 저장하고,

ar[a][1] 에는 현재의 값을 건너뛴다는 의미인 ar[a-1][0]과 이미 뛰어넘기를 사용한 전단계의 ar[a-1][0] + ar[a-1][1] 중 더 큰값을

저장하도록 하였습니다. 그리고 가장 큰값을 저장하는 big을 선언하여 사용한 모든 배열에서 가장 큰 값을 저장하고, big을 출력하여

문제를 해결하였습니다.


#include <cstdio>
#include <algorithm>
using namespace std;

int ar[100000][2] = { 0, }; // ar[][0]에는 뛰어넘기 사용, ar[][1]에는 뛰어넘기를  사용하지 않은 최대값 저장

int main() {
    int n;
    scanf("%d", &n);
    for (int a = 0; a < n; ++a) {
        scanf("%d", &ar[a][0]);
    }
    ar[0][1] = ar[0][0]; // 초기값 세팅
    int big = ar[0][0]; // 초기값 세팅
    for (int a = 1; a < n; ++a) {
        ar[a][1] = max(ar[a - 1][0], ar[a - 1][1] + ar[a][0]); // ar[a][1]에는 뛰어넘기를 사용했을 때 가장 큰값을 저장하므로, 
        // 1. 현재값을 뛰어넘기 사용했을 경우 - 뛰어넘기를 사용하지않은 ar[a-1][0] 
        // 2. 뛰어넘기를 사용한 뒤 현재값을 더하는 경우 - ar[a-1][1] + ar[a][0] 중 최대값 저장 
        ar[a][0] = max(ar[a][0], ar[a - 1][0]+ar[a][0]); // ar[a][0]에는 뛰어넘기를 사용하지 않았을 때 가장 큰 값이므로
        // 1. 현재 자신부터 수열을 시작하는 경우 - ar[a][0]
        // 2. 뛰어넘기를 사용하지 않은 전의 수열을 이어받아 수열을 진행하는 경우 - ar[a-1][0] + ar[a][0] 
    }
    for (int a = 0; a < n; ++a) {
            if (big < ar[a][0] || big < ar[a][1]){
                big = max(ar[a][0] , ar[a][1]); // 2중 for문을 이용하여 최대값 
        }
    }
    printf("%d", big);
    return 0;
}
