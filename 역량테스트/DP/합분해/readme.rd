문제 사이트 : https://www.acmicpc.net/problem/2225

설명 : 
0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

풀이
 문제의 해결방법을 찾기 위해 문제에 주어진 n값인 20을 기준으로 k를 늘려가며 규칙을 찾아보았을떄 다음과 같은 규칙을
 
 발견할 수 있었습니다.
 
 dp[k][a] = dp[k-1][a] + dp[k][a-1]
 
 위의 규칙은 k번 숫자를 사용하여 a라는 숫자를 만드는 경우의 수는, k-1번 숫자를 사용하여 a를 만들때 경우의 수와 
 
 k번 숫자를 사용하여 a-1이라는 숫자를 만들 떄의 합과 같다는 의미입니다.
 
 이러한 규칙이 나오는 이유는 dp[k][a]를 완성하기 위해서는
 
 sum(dp[k-1][0], dp[k-1][a])의 값이 필요한데
 
 dp[k][a-1]의 값은 sum(dp[k-1][0], dp[k-1][a-1])의 값과 같기 때문에 dp[k][a-1] + dp[k-1][a] 를 하면
 
 원하는 값을 얻는 식과 동일한 값을 얻을 수 있습니다.
 
 #include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

int ch[201] = { 0, }; // ch값은 전에 존재하던 값을 이용하여 현재의 값을 만들기 때문에
// 하나의 배열을 갱신해가며 재사용
int main() {
    int n, k;
    scanf("%d%d", &n,&k);
    for (int a = 0; a <= n; ++a) {
        ch[a] = 1; // 초기값 세팅
    }


    for (int a = 2; a <= k; ++a) {
        for (int b = 1; b <= n; ++b) {
            ch[b] = (ch[b - 1] + ch[b])%1000000000; // 위에서 설명한 dp규칙을 사용하여 ch값에 저장
        }
    }
    printf("%d", ch[n]);
    return 0;
}
